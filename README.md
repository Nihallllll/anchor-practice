Prerequisites you need in your head
1) Solana account model (quick, but essential)

Everything is an account. An account has:

lamports balance (native SOL).

owner program id (the only program allowed to write to its data).

data bytes (your serialized state).

optional executable flag.

Your program can only write to accounts it owns. “Ownership” here means account.owner == your_program_id.

Rent exemption: to store data, an account must hold a minimum lamports balance. When you “init” an account, you fund it to the rent-exempt minimum.

PDAs vs normal keypairs:

Normal account: generated by a keypair, must sign its own creation.

PDA: derived from seeds and your program id. It cannot sign, so your program signs on its behalf using invoke_signed.

2) What Anchor gives you

Anchor is a framework that:

Generates instruction handlers from your Rust functions marked with #[program].

Handles account validation using #[derive(Accounts)] structs.

Serializes and deserializes your data types marked with #[account].

Adds an 8-byte discriminator prefix to each account’s data so it knows which Rust type is stored inside.

Gives you wrappers like Account<'info, T> that ensure owner == program_id and do safe deserialization.

Provides macros like #[account(init, payer = ..., space = ...)] to automatically perform the System Program create-account CPI and fund rent.

Space math

Every #[account] has 8 bytes discriminator.

Then the sum of your field sizes. Example: a single u32 is 4 bytes.

So space = 8 + 4 is correct for { data: u32 }.

3) Rust bits that show up in your code

struct, impl, &self method receivers, and #[derive(Debug)] for {:?} formatting.

Result<()> is Anchor’s anchor_lang::Result, which is just std::result::Result<(), ProgramErrorLike>.

Integer math on-chain:

In debug builds, overflow panics.

In release builds (what runs on-chain), overflow wraps silently modulo 2^N. That means u32::MAX + 1 becomes 0. Use checked_* methods if you want safety.

On Solana, prefer msg!() for logging. println! is for standard I/O and is not what you want in programs.

Now, your file, line by line
use anchor_lang::prelude::*;


Pulls in common Anchor items: Context, Account, Signer, Program, Result, msg!, Pubkey, and more. Think of it as “standard imports” for Anchor.

#[derive(Debug)]
struct Rect {
    width: u32,
    height: u32,
}

impl Rect {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}


This is a plain Rust struct with a helper method. It is not an on-chain account. It is allocated on the stack when you create it inside an instruction. #[derive(Debug)] lets you format it with {:?}. The area() method is not used in your current code. If you wanted to, you could log rect.area() with msg!.

declare_id!("");


This must be your program id (the public key of the deploy keypair), for example:

declare_id!("Fh3...YourProgramId...7Zn");


Anchor checks this at runtime to prevent mismatched IDs. Leaving it empty will fail.

#[program]
pub mod anchor_calculator {
    use super::*;


#[program] tells Anchor “generate entrypoints for the functions in this module as instructions.” use super::* brings your outer scope into the module.

Instruction: initialize
    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
        ctx.accounts.new_account.data = 1;
        let rect = Rect {
            width: 10,
            height: 20,
        };
        println!("Rect: {:?}", rect);
        Ok(())
    }


What Anchor does before your code runs:

Looks at Context<Initialize>. That points to your #[derive(Accounts)] struct named Initialize (defined later).

Sees #[account(init, payer = signer, space = 8 + 4)] on new_account. So Anchor:

Calls the System Program to create new_account with the correct space.

Funds it to the rent-exempt minimum using signer’s lamports.

Sets its owner to your program.

Writes the 8-byte discriminator for NewAccount.

Then your handler runs:

ctx.accounts.new_account.data = 1;

You write 1 into the data field of your newly created account.

You create a Rect. That is just a local Rust variable.

println!("Rect: {:?}", rect);

For on-chain logs, do not use println!. Use:

msg!("Rect: {:?}", rect);


msg! output shows up in transaction logs.

Return Ok(()).

Important nuance: This init is for a non-PDA account because you did not provide seeds=[...]. That means the client must pass a brand new keypair for new_account and sign with it. Anchor enforces that in this init flow.

Instruction: double
    pub fn double(ctx: Context<Double>) -> Result<()> {
        ctx.accounts.account.data = ctx.accounts.account.data * 2;
        Ok(())
    }


Anchor ensures account is owned by your program and is of type NewAccount.

You multiply by 2. In on-chain release builds, u32 overflow wraps. If data is near u32::MAX/2, it will wrap to a small number. If you want safety:

let x = ctx.accounts.account.data.checked_mul(2).ok_or(ErrorCode::Overflow)?;
ctx.accounts.account.data = x;

Instruction: halve
    pub fn halve(ctx: Context<Halve>) -> Result<()> {
        ctx.accounts.account.data = ctx.accounts.account.data / 2;
        Ok(())
    }


Integer division truncates toward zero. If data is odd, you drop the remainder.

No divide-by-zero risk here because you divide by a literal 2.

Instruction: add
    pub fn add(ctx: Context<Add>, amount: u32) -> Result<()> {
        ctx.accounts.account.data = ctx.accounts.account.data + amount;
        Ok(())
    }


Same overflow concern as above. Prefer checked_add.

Instruction: sub
    pub fn sub(ctx: Context<Sub>, amount: u32) -> Result<()> {
        ctx.accounts.account.data = ctx.accounts.account.data - amount;
        Ok(())
    }


Underflow risk. 0 - 1 wraps to u32::MAX in release builds. Prefer checked_sub.

Your persistent account type
#[account]
pub struct NewAccount {
    data: u32,
}


#[account] tells Anchor to serialize this into account data with an 8-byte discriminator prefix.

Layout on-chain is:

8 bytes discriminator

4 bytes data

Account validation structs

These structs define what accounts each instruction expects and the constraints on them. Anchor builds validations from the attributes so you do not have to write manual checks.

Initialize
#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = signer, space = 8 + 4)]
    pub new_account: Account<'info, NewAccount>,
    #[account(mut)]
    pub signer: Signer<'info>,
    pub system_program: Program<'info, System>,
}


new_account:

init: create it now.

payer = signer: charge the signer for rent.

space = 8 + 4: discriminator + u32. Correct.

This is a non-PDA init. The client must pass a new keypair for new_account and include it as a signer in the transaction. Anchor enforces that automatically for non-PDA init.

signer:

Must be mutable because lamports will decrease to pay rent.

system_program:

Required to perform the CPI that actually creates the account.

Double, Halve, Add, Sub
#[derive(Accounts)]
pub struct Double<'info> {
    #[account(mut)]
    pub account: Account<'info, NewAccount>,
    pub signer: Signer<'info>,
}


(and the others are the same shape)

account must be mutable and owned by your program.

signer exists, but there is no relationship enforced between signer and account. Any signer can come along and modify any NewAccount they can pass to the instruction. That is usually not what you want.

What works, what breaks, what to harden
Works

Space calculation 8 + 4 is correct.

Init flow funds rent and sets owner to your program.

The math compiles and runs.

Needs fixes

Program id
Fill in declare_id!("YourProgramIdHere").

Logging
Replace println! with msg!.

Authority
Right now anyone can call add, sub, double, halve on anyone’s NewAccount. If you want only the creator to change it, store an authority: Pubkey in NewAccount and enforce has_one = authority with the signer being that authority.

Math safety
Use checked_add, checked_sub, checked_mul to avoid wraparound.

Deterministic address (optional but recommended)
Use a PDA so users do not need to generate throwaway keypairs. PDAs also protect you from account address collisions and make address derivation deterministic from seeds.

A tightened version of your program

This adds:

msg! logging

An authority field

PDA with seeds [b"calc", authority]

Checked math with custom Anchor errors

use anchor_lang::prelude::*;

declare_id!("ReplaceWithYourProgramId");

#[account]
pub struct NewAccount {
    pub authority: Pubkey,
    pub data: u32,
}

#[error_code]
pub enum ErrorCode {
    #[msg("Arithmetic overflow or underflow")]
    MathError,
    #[msg("Only the authority may modify this account")]
    Unauthorized,
}

#[program]
pub mod anchor_calculator {
    use super::*;

    pub fn initialize(ctx: Context<Initialize>) -> Result<()> {
        let acct = &mut ctx.accounts.new_account;
        acct.authority = ctx.accounts.signer.key();
        acct.data = 1;

        let rect = Rect { width: 10, height: 20 };
        msg!("Rect: {:?}", rect);
        msg!("Area: {}", rect.area());
        Ok(())
    }

    pub fn double(ctx: Context<Modify>) -> Result<()> {
        only_authority(&ctx.accounts.account, &ctx.accounts.authority)?;
        let x = ctx.accounts.account.data.checked_mul(2).ok_or(ErrorCode::MathError)?;
        ctx.accounts.account.data = x;
        Ok(())
    }

    pub fn halve(ctx: Context<Modify>) -> Result<()> {
        only_authority(&ctx.accounts.account, &ctx.accounts.authority)?;
        ctx.accounts.account.data /= 2;
        Ok(())
    }

    pub fn add(ctx: Context<ModifyWithAmount>, amount: u32) -> Result<()> {
        only_authority(&ctx.accounts.account, &ctx.accounts.authority)?;
        let x = ctx.accounts.account.data.checked_add(amount).ok_or(ErrorCode::MathError)?;
        ctx.accounts.account.data = x;
        Ok(())
    }

    pub fn sub(ctx: Context<ModifyWithAmount>, amount: u32) -> Result<()> {
        only_authority(&ctx.accounts.account, &ctx.accounts.authority)?;
        let x = ctx.accounts.account.data.checked_sub(amount).ok_or(ErrorCode::MathError)?;
        ctx.accounts.account.data = x;
        Ok(())
    }
}

fn only_authority(acct: &Account<NewAccount>, signer: &Signer) -> Result<()> {
    require_keys_eq!(acct.authority, signer.key(), ErrorCode::Unauthorized);
    Ok(())
}

#[derive(Debug)]
struct Rect {
    width: u32,
    height: u32,
}
impl Rect {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(
        init,
        payer = signer,
        space = 8 + 32 + 4,
        seeds = [b"calc", signer.key().as_ref()],
        bump
    )]
    pub new_account: Account<'info, NewAccount>,
    #[account(mut)]
    pub signer: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct Modify<'info> {
    #[account(
        mut,
        seeds = [b"calc", authority.key().as_ref()],
        bump,
        has_one = authority
    )]
    pub account: Account<'info, NewAccount>,
    pub authority: Signer<'info>,
}

#[derive(Accounts)]
pub struct ModifyWithAmount<'info> {
    #[account(
        mut,
        seeds = [b"calc", authority.key().as_ref()],
        bump,
        has_one = authority
    )]
    pub account: Account<'info, NewAccount>,
    pub authority: Signer<'info>,
}


Notes on the changes

NewAccount now stores authority: Pubkey. We enforce it with has_one = authority and by requiring authority to be a Signer<'info>.

We switched to PDA accounts derived from [b"calc", signer.key()]. No need for clients to generate a throwaway keypair. PDAs are recreated deterministically.

space = 8 + 32 + 4 for discriminator + Pubkey + u32.

checked_* math to prevent silent wraparound.

msg! for logs.

require_keys_eq! for simple access control.

What Anchor validates for you in each instruction

For any context struct:

Ownership: Account<'info, T> ensures the account is owned by your program.

Type: the 8-byte discriminator matches T before deserialization.

Mutability: #[account(mut)] ensures the runtime marks it writable.

Init: #[account(init, ...)] triggers a System Program create-account CPI and writes the discriminator.

Seeds/bump: If you use seeds = [...] and bump, Anchor re-derives the PDA and checks the address matches the one you passed.

has_one: Verifies a field inside the account equals the provided account’s key.

Tiny client sketch (TypeScript with Anchor)

This shows the flow to init and then add.

import * as anchor from "@coral-xyz/anchor";
import { PublicKey } from "@solana/web3.js";

const provider = anchor.AnchorProvider.env();
anchor.setProvider(provider);

const program = anchor.workspace.AnchorCalculator as anchor.Program<any>;
const authority = provider.wallet.publicKey;

// Derive PDA the same way as in the program
const [accountPda] = PublicKey.findProgramAddressSync(
  [Buffer.from("calc"), authority.toBuffer()],
  program.programId
);

// Initialize (creates PDA if not exists)
await program.methods
  .initialize()
  .accounts({
    newAccount: accountPda,
    signer: authority,
    systemProgram: anchor.web3.SystemProgram.programId,
  })
  .rpc();

// Read the account
let acct = await program.account.newAccount.fetch(accountPda);
console.log("After init:", acct);

// Add 7
await program.methods
  .add(new anchor.BN(7))
  .accounts({
    account: accountPda,
    authority,
  })
  .rpc();

acct = await program.account.newAccount.fetch(accountPda);
console.log("After add:", acct);

Common gotchas you just dodged (or should fix)

Empty declare_id! will fail sanity checks. Put the real id.

println! on-chain is not for Solana. Use msg!.

No authority in state means anyone can modify anyone’s account. Store authority and enforce it.

Overflow/underflow will wrap in release. Use checked_* and return a helpful error.

Space math must include discriminator. You did that right.

Init without seeds means a non-PDA account. That works but the client must provide and sign a fresh keypair. Most apps prefer PDAs.
